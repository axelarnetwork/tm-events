// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"sync"
)

// Ensure, that QueryMock does implement Query.
// If this is not the case, regenerate this file with moq.
var _ Query = &QueryMock{}

// QueryMock is a mock implementation of Query.
//
//	func TestSomethingThatUsesQuery(t *testing.T) {
//
//		// make and configure a mocked Query
//		mockedQuery := &QueryMock{
//			MatchesFunc: func(events map[string][]string) (bool, error) {
//				panic("mock out the Matches method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedQuery in code that requires Query
//		// and then make assertions.
//
//	}
type QueryMock struct {
	// MatchesFunc mocks the Matches method.
	MatchesFunc func(events map[string][]string) (bool, error)

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Matches holds details about calls to the Matches method.
		Matches []struct {
			// Events is the events argument value.
			Events map[string][]string
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockMatches sync.RWMutex
	lockString  sync.RWMutex
}

// Matches calls MatchesFunc.
func (mock *QueryMock) Matches(events map[string][]string) (bool, error) {
	if mock.MatchesFunc == nil {
		panic("QueryMock.MatchesFunc: method is nil but Query.Matches was just called")
	}
	callInfo := struct {
		Events map[string][]string
	}{
		Events: events,
	}
	mock.lockMatches.Lock()
	mock.calls.Matches = append(mock.calls.Matches, callInfo)
	mock.lockMatches.Unlock()
	return mock.MatchesFunc(events)
}

// MatchesCalls gets all the calls that were made to Matches.
// Check the length with:
//
//	len(mockedQuery.MatchesCalls())
func (mock *QueryMock) MatchesCalls() []struct {
	Events map[string][]string
} {
	var calls []struct {
		Events map[string][]string
	}
	mock.lockMatches.RLock()
	calls = mock.calls.Matches
	mock.lockMatches.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *QueryMock) String() string {
	if mock.StringFunc == nil {
		panic("QueryMock.StringFunc: method is nil but Query.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedQuery.StringCalls())
func (mock *QueryMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}
