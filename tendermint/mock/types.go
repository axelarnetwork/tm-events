// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/cometbft/cometbft/libs/bytes"
	"github.com/cometbft/cometbft/libs/log"
	"github.com/cometbft/cometbft/rpc/client"
	"github.com/cometbft/cometbft/rpc/core/types"
	"github.com/cometbft/cometbft/types"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &ClientMock{
//			ABCIInfoFunc: func(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error) {
//				panic("mock out the ABCIInfo method")
//			},
//			ABCIQueryFunc: func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
//				panic("mock out the ABCIQuery method")
//			},
//			ABCIQueryWithOptionsFunc: func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
//				panic("mock out the ABCIQueryWithOptions method")
//			},
//			BlockFunc: func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
//				panic("mock out the Block method")
//			},
//			BlockByHashFunc: func(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error) {
//				panic("mock out the BlockByHash method")
//			},
//			BlockResultsFunc: func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
//				panic("mock out the BlockResults method")
//			},
//			BlockSearchFunc: func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
//				panic("mock out the BlockSearch method")
//			},
//			BlockchainInfoFunc: func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
//				panic("mock out the BlockchainInfo method")
//			},
//			BroadcastEvidenceFunc: func(contextMoqParam context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
//				panic("mock out the BroadcastEvidence method")
//			},
//			BroadcastTxAsyncFunc: func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
//				panic("mock out the BroadcastTxAsync method")
//			},
//			BroadcastTxCommitFunc: func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
//				panic("mock out the BroadcastTxCommit method")
//			},
//			BroadcastTxSyncFunc: func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
//				panic("mock out the BroadcastTxSync method")
//			},
//			CheckTxFunc: func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error) {
//				panic("mock out the CheckTx method")
//			},
//			CommitFunc: func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
//				panic("mock out the Commit method")
//			},
//			ConsensusParamsFunc: func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
//				panic("mock out the ConsensusParams method")
//			},
//			ConsensusStateFunc: func(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error) {
//				panic("mock out the ConsensusState method")
//			},
//			DumpConsensusStateFunc: func(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error) {
//				panic("mock out the DumpConsensusState method")
//			},
//			GenesisFunc: func(contextMoqParam context.Context) (*coretypes.ResultGenesis, error) {
//				panic("mock out the Genesis method")
//			},
//			GenesisChunkedFunc: func(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
//				panic("mock out the GenesisChunked method")
//			},
//			HeaderFunc: func(ctx context.Context, height *int64) (*coretypes.ResultHeader, error) {
//				panic("mock out the Header method")
//			},
//			HeaderByHashFunc: func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error) {
//				panic("mock out the HeaderByHash method")
//			},
//			HealthFunc: func(contextMoqParam context.Context) (*coretypes.ResultHealth, error) {
//				panic("mock out the Health method")
//			},
//			IsRunningFunc: func() bool {
//				panic("mock out the IsRunning method")
//			},
//			NetInfoFunc: func(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error) {
//				panic("mock out the NetInfo method")
//			},
//			NumUnconfirmedTxsFunc: func(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
//				panic("mock out the NumUnconfirmedTxs method")
//			},
//			OnResetFunc: func() error {
//				panic("mock out the OnReset method")
//			},
//			OnStartFunc: func() error {
//				panic("mock out the OnStart method")
//			},
//			OnStopFunc: func()  {
//				panic("mock out the OnStop method")
//			},
//			QuitFunc: func() <-chan struct{} {
//				panic("mock out the Quit method")
//			},
//			ResetFunc: func() error {
//				panic("mock out the Reset method")
//			},
//			SetLoggerFunc: func(logger log.Logger)  {
//				panic("mock out the SetLogger method")
//			},
//			StartFunc: func() error {
//				panic("mock out the Start method")
//			},
//			StatusFunc: func(contextMoqParam context.Context) (*coretypes.ResultStatus, error) {
//				panic("mock out the Status method")
//			},
//			StopFunc: func() error {
//				panic("mock out the Stop method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			SubscribeFunc: func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
//				panic("mock out the Subscribe method")
//			},
//			TxFunc: func(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error) {
//				panic("mock out the Tx method")
//			},
//			TxSearchFunc: func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
//				panic("mock out the TxSearch method")
//			},
//			UnconfirmedTxsFunc: func(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error) {
//				panic("mock out the UnconfirmedTxs method")
//			},
//			UnsubscribeFunc: func(ctx context.Context, subscriber string, query string) error {
//				panic("mock out the Unsubscribe method")
//			},
//			UnsubscribeAllFunc: func(ctx context.Context, subscriber string) error {
//				panic("mock out the UnsubscribeAll method")
//			},
//			ValidatorsFunc: func(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error) {
//				panic("mock out the Validators method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// ABCIInfoFunc mocks the ABCIInfo method.
	ABCIInfoFunc func(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error)

	// ABCIQueryFunc mocks the ABCIQuery method.
	ABCIQueryFunc func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error)

	// ABCIQueryWithOptionsFunc mocks the ABCIQueryWithOptions method.
	ABCIQueryWithOptionsFunc func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)

	// BlockFunc mocks the Block method.
	BlockFunc func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error)

	// BlockByHashFunc mocks the BlockByHash method.
	BlockByHashFunc func(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error)

	// BlockResultsFunc mocks the BlockResults method.
	BlockResultsFunc func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error)

	// BlockSearchFunc mocks the BlockSearch method.
	BlockSearchFunc func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error)

	// BlockchainInfoFunc mocks the BlockchainInfo method.
	BlockchainInfoFunc func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error)

	// BroadcastEvidenceFunc mocks the BroadcastEvidence method.
	BroadcastEvidenceFunc func(contextMoqParam context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error)

	// BroadcastTxAsyncFunc mocks the BroadcastTxAsync method.
	BroadcastTxAsyncFunc func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)

	// BroadcastTxCommitFunc mocks the BroadcastTxCommit method.
	BroadcastTxCommitFunc func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error)

	// BroadcastTxSyncFunc mocks the BroadcastTxSync method.
	BroadcastTxSyncFunc func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)

	// CheckTxFunc mocks the CheckTx method.
	CheckTxFunc func(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error)

	// CommitFunc mocks the Commit method.
	CommitFunc func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error)

	// ConsensusParamsFunc mocks the ConsensusParams method.
	ConsensusParamsFunc func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error)

	// ConsensusStateFunc mocks the ConsensusState method.
	ConsensusStateFunc func(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error)

	// DumpConsensusStateFunc mocks the DumpConsensusState method.
	DumpConsensusStateFunc func(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error)

	// GenesisFunc mocks the Genesis method.
	GenesisFunc func(contextMoqParam context.Context) (*coretypes.ResultGenesis, error)

	// GenesisChunkedFunc mocks the GenesisChunked method.
	GenesisChunkedFunc func(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error)

	// HeaderFunc mocks the Header method.
	HeaderFunc func(ctx context.Context, height *int64) (*coretypes.ResultHeader, error)

	// HeaderByHashFunc mocks the HeaderByHash method.
	HeaderByHashFunc func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error)

	// HealthFunc mocks the Health method.
	HealthFunc func(contextMoqParam context.Context) (*coretypes.ResultHealth, error)

	// IsRunningFunc mocks the IsRunning method.
	IsRunningFunc func() bool

	// NetInfoFunc mocks the NetInfo method.
	NetInfoFunc func(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error)

	// NumUnconfirmedTxsFunc mocks the NumUnconfirmedTxs method.
	NumUnconfirmedTxsFunc func(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error)

	// OnResetFunc mocks the OnReset method.
	OnResetFunc func() error

	// OnStartFunc mocks the OnStart method.
	OnStartFunc func() error

	// OnStopFunc mocks the OnStop method.
	OnStopFunc func()

	// QuitFunc mocks the Quit method.
	QuitFunc func() <-chan struct{}

	// ResetFunc mocks the Reset method.
	ResetFunc func() error

	// SetLoggerFunc mocks the SetLogger method.
	SetLoggerFunc func(logger log.Logger)

	// StartFunc mocks the Start method.
	StartFunc func() error

	// StatusFunc mocks the Status method.
	StatusFunc func(contextMoqParam context.Context) (*coretypes.ResultStatus, error)

	// StopFunc mocks the Stop method.
	StopFunc func() error

	// StringFunc mocks the String method.
	StringFunc func() string

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error)

	// TxFunc mocks the Tx method.
	TxFunc func(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error)

	// TxSearchFunc mocks the TxSearch method.
	TxSearchFunc func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error)

	// UnconfirmedTxsFunc mocks the UnconfirmedTxs method.
	UnconfirmedTxsFunc func(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error)

	// UnsubscribeFunc mocks the Unsubscribe method.
	UnsubscribeFunc func(ctx context.Context, subscriber string, query string) error

	// UnsubscribeAllFunc mocks the UnsubscribeAll method.
	UnsubscribeAllFunc func(ctx context.Context, subscriber string) error

	// ValidatorsFunc mocks the Validators method.
	ValidatorsFunc func(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error)

	// calls tracks calls to the methods.
	calls struct {
		// ABCIInfo holds details about calls to the ABCIInfo method.
		ABCIInfo []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// ABCIQuery holds details about calls to the ABCIQuery method.
		ABCIQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data bytes.HexBytes
		}
		// ABCIQueryWithOptions holds details about calls to the ABCIQueryWithOptions method.
		ABCIQueryWithOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data bytes.HexBytes
			// Opts is the opts argument value.
			Opts client.ABCIQueryOptions
		}
		// Block holds details about calls to the Block method.
		Block []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// BlockByHash holds details about calls to the BlockByHash method.
		BlockByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
		}
		// BlockResults holds details about calls to the BlockResults method.
		BlockResults []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// BlockSearch holds details about calls to the BlockSearch method.
		BlockSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
			// OrderBy is the orderBy argument value.
			OrderBy string
		}
		// BlockchainInfo holds details about calls to the BlockchainInfo method.
		BlockchainInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// MinHeight is the minHeight argument value.
			MinHeight int64
			// MaxHeight is the maxHeight argument value.
			MaxHeight int64
		}
		// BroadcastEvidence holds details about calls to the BroadcastEvidence method.
		BroadcastEvidence []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Evidence is the evidence argument value.
			Evidence types.Evidence
		}
		// BroadcastTxAsync holds details about calls to the BroadcastTxAsync method.
		BroadcastTxAsync []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx types.Tx
		}
		// BroadcastTxCommit holds details about calls to the BroadcastTxCommit method.
		BroadcastTxCommit []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx types.Tx
		}
		// BroadcastTxSync holds details about calls to the BroadcastTxSync method.
		BroadcastTxSync []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx types.Tx
		}
		// CheckTx holds details about calls to the CheckTx method.
		CheckTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx types.Tx
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// ConsensusParams holds details about calls to the ConsensusParams method.
		ConsensusParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// ConsensusState holds details about calls to the ConsensusState method.
		ConsensusState []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// DumpConsensusState holds details about calls to the DumpConsensusState method.
		DumpConsensusState []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Genesis holds details about calls to the Genesis method.
		Genesis []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// GenesisChunked holds details about calls to the GenesisChunked method.
		GenesisChunked []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// V is the v argument value.
			V uint
		}
		// Header holds details about calls to the Header method.
		Header []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// HeaderByHash holds details about calls to the HeaderByHash method.
		HeaderByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash bytes.HexBytes
		}
		// Health holds details about calls to the Health method.
		Health []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// IsRunning holds details about calls to the IsRunning method.
		IsRunning []struct {
		}
		// NetInfo holds details about calls to the NetInfo method.
		NetInfo []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// NumUnconfirmedTxs holds details about calls to the NumUnconfirmedTxs method.
		NumUnconfirmedTxs []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// OnReset holds details about calls to the OnReset method.
		OnReset []struct {
		}
		// OnStart holds details about calls to the OnStart method.
		OnStart []struct {
		}
		// OnStop holds details about calls to the OnStop method.
		OnStop []struct {
		}
		// Quit holds details about calls to the Quit method.
		Quit []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// SetLogger holds details about calls to the SetLogger method.
		SetLogger []struct {
			// Logger is the logger argument value.
			Logger log.Logger
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// Status holds details about calls to the Status method.
		Status []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
			// Query is the query argument value.
			Query string
			// OutCapacity is the outCapacity argument value.
			OutCapacity []int
		}
		// Tx holds details about calls to the Tx method.
		Tx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
			// Prove is the prove argument value.
			Prove bool
		}
		// TxSearch holds details about calls to the TxSearch method.
		TxSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Prove is the prove argument value.
			Prove bool
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
			// OrderBy is the orderBy argument value.
			OrderBy string
		}
		// UnconfirmedTxs holds details about calls to the UnconfirmedTxs method.
		UnconfirmedTxs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit *int
		}
		// Unsubscribe holds details about calls to the Unsubscribe method.
		Unsubscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
			// Query is the query argument value.
			Query string
		}
		// UnsubscribeAll holds details about calls to the UnsubscribeAll method.
		UnsubscribeAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
		}
		// Validators holds details about calls to the Validators method.
		Validators []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
		}
	}
	lockABCIInfo             sync.RWMutex
	lockABCIQuery            sync.RWMutex
	lockABCIQueryWithOptions sync.RWMutex
	lockBlock                sync.RWMutex
	lockBlockByHash          sync.RWMutex
	lockBlockResults         sync.RWMutex
	lockBlockSearch          sync.RWMutex
	lockBlockchainInfo       sync.RWMutex
	lockBroadcastEvidence    sync.RWMutex
	lockBroadcastTxAsync     sync.RWMutex
	lockBroadcastTxCommit    sync.RWMutex
	lockBroadcastTxSync      sync.RWMutex
	lockCheckTx              sync.RWMutex
	lockCommit               sync.RWMutex
	lockConsensusParams      sync.RWMutex
	lockConsensusState       sync.RWMutex
	lockDumpConsensusState   sync.RWMutex
	lockGenesis              sync.RWMutex
	lockGenesisChunked       sync.RWMutex
	lockHeader               sync.RWMutex
	lockHeaderByHash         sync.RWMutex
	lockHealth               sync.RWMutex
	lockIsRunning            sync.RWMutex
	lockNetInfo              sync.RWMutex
	lockNumUnconfirmedTxs    sync.RWMutex
	lockOnReset              sync.RWMutex
	lockOnStart              sync.RWMutex
	lockOnStop               sync.RWMutex
	lockQuit                 sync.RWMutex
	lockReset                sync.RWMutex
	lockSetLogger            sync.RWMutex
	lockStart                sync.RWMutex
	lockStatus               sync.RWMutex
	lockStop                 sync.RWMutex
	lockString               sync.RWMutex
	lockSubscribe            sync.RWMutex
	lockTx                   sync.RWMutex
	lockTxSearch             sync.RWMutex
	lockUnconfirmedTxs       sync.RWMutex
	lockUnsubscribe          sync.RWMutex
	lockUnsubscribeAll       sync.RWMutex
	lockValidators           sync.RWMutex
}

// ABCIInfo calls ABCIInfoFunc.
func (mock *ClientMock) ABCIInfo(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error) {
	if mock.ABCIInfoFunc == nil {
		panic("ClientMock.ABCIInfoFunc: method is nil but Client.ABCIInfo was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockABCIInfo.Lock()
	mock.calls.ABCIInfo = append(mock.calls.ABCIInfo, callInfo)
	mock.lockABCIInfo.Unlock()
	return mock.ABCIInfoFunc(contextMoqParam)
}

// ABCIInfoCalls gets all the calls that were made to ABCIInfo.
// Check the length with:
//
//	len(mockedClient.ABCIInfoCalls())
func (mock *ClientMock) ABCIInfoCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockABCIInfo.RLock()
	calls = mock.calls.ABCIInfo
	mock.lockABCIInfo.RUnlock()
	return calls
}

// ABCIQuery calls ABCIQueryFunc.
func (mock *ClientMock) ABCIQuery(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
	if mock.ABCIQueryFunc == nil {
		panic("ClientMock.ABCIQueryFunc: method is nil but Client.ABCIQuery was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
	}{
		Ctx:  ctx,
		Path: path,
		Data: data,
	}
	mock.lockABCIQuery.Lock()
	mock.calls.ABCIQuery = append(mock.calls.ABCIQuery, callInfo)
	mock.lockABCIQuery.Unlock()
	return mock.ABCIQueryFunc(ctx, path, data)
}

// ABCIQueryCalls gets all the calls that were made to ABCIQuery.
// Check the length with:
//
//	len(mockedClient.ABCIQueryCalls())
func (mock *ClientMock) ABCIQueryCalls() []struct {
	Ctx  context.Context
	Path string
	Data bytes.HexBytes
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
	}
	mock.lockABCIQuery.RLock()
	calls = mock.calls.ABCIQuery
	mock.lockABCIQuery.RUnlock()
	return calls
}

// ABCIQueryWithOptions calls ABCIQueryWithOptionsFunc.
func (mock *ClientMock) ABCIQueryWithOptions(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
	if mock.ABCIQueryWithOptionsFunc == nil {
		panic("ClientMock.ABCIQueryWithOptionsFunc: method is nil but Client.ABCIQueryWithOptions was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
		Opts client.ABCIQueryOptions
	}{
		Ctx:  ctx,
		Path: path,
		Data: data,
		Opts: opts,
	}
	mock.lockABCIQueryWithOptions.Lock()
	mock.calls.ABCIQueryWithOptions = append(mock.calls.ABCIQueryWithOptions, callInfo)
	mock.lockABCIQueryWithOptions.Unlock()
	return mock.ABCIQueryWithOptionsFunc(ctx, path, data, opts)
}

// ABCIQueryWithOptionsCalls gets all the calls that were made to ABCIQueryWithOptions.
// Check the length with:
//
//	len(mockedClient.ABCIQueryWithOptionsCalls())
func (mock *ClientMock) ABCIQueryWithOptionsCalls() []struct {
	Ctx  context.Context
	Path string
	Data bytes.HexBytes
	Opts client.ABCIQueryOptions
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
		Opts client.ABCIQueryOptions
	}
	mock.lockABCIQueryWithOptions.RLock()
	calls = mock.calls.ABCIQueryWithOptions
	mock.lockABCIQueryWithOptions.RUnlock()
	return calls
}

// Block calls BlockFunc.
func (mock *ClientMock) Block(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
	if mock.BlockFunc == nil {
		panic("ClientMock.BlockFunc: method is nil but Client.Block was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlock.Lock()
	mock.calls.Block = append(mock.calls.Block, callInfo)
	mock.lockBlock.Unlock()
	return mock.BlockFunc(ctx, height)
}

// BlockCalls gets all the calls that were made to Block.
// Check the length with:
//
//	len(mockedClient.BlockCalls())
func (mock *ClientMock) BlockCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockBlock.RLock()
	calls = mock.calls.Block
	mock.lockBlock.RUnlock()
	return calls
}

// BlockByHash calls BlockByHashFunc.
func (mock *ClientMock) BlockByHash(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error) {
	if mock.BlockByHashFunc == nil {
		panic("ClientMock.BlockByHashFunc: method is nil but Client.BlockByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash []byte
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockByHash.Lock()
	mock.calls.BlockByHash = append(mock.calls.BlockByHash, callInfo)
	mock.lockBlockByHash.Unlock()
	return mock.BlockByHashFunc(ctx, hash)
}

// BlockByHashCalls gets all the calls that were made to BlockByHash.
// Check the length with:
//
//	len(mockedClient.BlockByHashCalls())
func (mock *ClientMock) BlockByHashCalls() []struct {
	Ctx  context.Context
	Hash []byte
} {
	var calls []struct {
		Ctx  context.Context
		Hash []byte
	}
	mock.lockBlockByHash.RLock()
	calls = mock.calls.BlockByHash
	mock.lockBlockByHash.RUnlock()
	return calls
}

// BlockResults calls BlockResultsFunc.
func (mock *ClientMock) BlockResults(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
	if mock.BlockResultsFunc == nil {
		panic("ClientMock.BlockResultsFunc: method is nil but Client.BlockResults was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockResults.Lock()
	mock.calls.BlockResults = append(mock.calls.BlockResults, callInfo)
	mock.lockBlockResults.Unlock()
	return mock.BlockResultsFunc(ctx, height)
}

// BlockResultsCalls gets all the calls that were made to BlockResults.
// Check the length with:
//
//	len(mockedClient.BlockResultsCalls())
func (mock *ClientMock) BlockResultsCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockBlockResults.RLock()
	calls = mock.calls.BlockResults
	mock.lockBlockResults.RUnlock()
	return calls
}

// BlockSearch calls BlockSearchFunc.
func (mock *ClientMock) BlockSearch(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
	if mock.BlockSearchFunc == nil {
		panic("ClientMock.BlockSearchFunc: method is nil but Client.BlockSearch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Page    *int
		PerPage *int
		OrderBy string
	}{
		Ctx:     ctx,
		Query:   query,
		Page:    page,
		PerPage: perPage,
		OrderBy: orderBy,
	}
	mock.lockBlockSearch.Lock()
	mock.calls.BlockSearch = append(mock.calls.BlockSearch, callInfo)
	mock.lockBlockSearch.Unlock()
	return mock.BlockSearchFunc(ctx, query, page, perPage, orderBy)
}

// BlockSearchCalls gets all the calls that were made to BlockSearch.
// Check the length with:
//
//	len(mockedClient.BlockSearchCalls())
func (mock *ClientMock) BlockSearchCalls() []struct {
	Ctx     context.Context
	Query   string
	Page    *int
	PerPage *int
	OrderBy string
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Page    *int
		PerPage *int
		OrderBy string
	}
	mock.lockBlockSearch.RLock()
	calls = mock.calls.BlockSearch
	mock.lockBlockSearch.RUnlock()
	return calls
}

// BlockchainInfo calls BlockchainInfoFunc.
func (mock *ClientMock) BlockchainInfo(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
	if mock.BlockchainInfoFunc == nil {
		panic("ClientMock.BlockchainInfoFunc: method is nil but Client.BlockchainInfo was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		MinHeight int64
		MaxHeight int64
	}{
		Ctx:       ctx,
		MinHeight: minHeight,
		MaxHeight: maxHeight,
	}
	mock.lockBlockchainInfo.Lock()
	mock.calls.BlockchainInfo = append(mock.calls.BlockchainInfo, callInfo)
	mock.lockBlockchainInfo.Unlock()
	return mock.BlockchainInfoFunc(ctx, minHeight, maxHeight)
}

// BlockchainInfoCalls gets all the calls that were made to BlockchainInfo.
// Check the length with:
//
//	len(mockedClient.BlockchainInfoCalls())
func (mock *ClientMock) BlockchainInfoCalls() []struct {
	Ctx       context.Context
	MinHeight int64
	MaxHeight int64
} {
	var calls []struct {
		Ctx       context.Context
		MinHeight int64
		MaxHeight int64
	}
	mock.lockBlockchainInfo.RLock()
	calls = mock.calls.BlockchainInfo
	mock.lockBlockchainInfo.RUnlock()
	return calls
}

// BroadcastEvidence calls BroadcastEvidenceFunc.
func (mock *ClientMock) BroadcastEvidence(contextMoqParam context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
	if mock.BroadcastEvidenceFunc == nil {
		panic("ClientMock.BroadcastEvidenceFunc: method is nil but Client.BroadcastEvidence was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Evidence        types.Evidence
	}{
		ContextMoqParam: contextMoqParam,
		Evidence:        evidence,
	}
	mock.lockBroadcastEvidence.Lock()
	mock.calls.BroadcastEvidence = append(mock.calls.BroadcastEvidence, callInfo)
	mock.lockBroadcastEvidence.Unlock()
	return mock.BroadcastEvidenceFunc(contextMoqParam, evidence)
}

// BroadcastEvidenceCalls gets all the calls that were made to BroadcastEvidence.
// Check the length with:
//
//	len(mockedClient.BroadcastEvidenceCalls())
func (mock *ClientMock) BroadcastEvidenceCalls() []struct {
	ContextMoqParam context.Context
	Evidence        types.Evidence
} {
	var calls []struct {
		ContextMoqParam context.Context
		Evidence        types.Evidence
	}
	mock.lockBroadcastEvidence.RLock()
	calls = mock.calls.BroadcastEvidence
	mock.lockBroadcastEvidence.RUnlock()
	return calls
}

// BroadcastTxAsync calls BroadcastTxAsyncFunc.
func (mock *ClientMock) BroadcastTxAsync(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	if mock.BroadcastTxAsyncFunc == nil {
		panic("ClientMock.BroadcastTxAsyncFunc: method is nil but Client.BroadcastTxAsync was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxAsync.Lock()
	mock.calls.BroadcastTxAsync = append(mock.calls.BroadcastTxAsync, callInfo)
	mock.lockBroadcastTxAsync.Unlock()
	return mock.BroadcastTxAsyncFunc(contextMoqParam, tx)
}

// BroadcastTxAsyncCalls gets all the calls that were made to BroadcastTxAsync.
// Check the length with:
//
//	len(mockedClient.BroadcastTxAsyncCalls())
func (mock *ClientMock) BroadcastTxAsyncCalls() []struct {
	ContextMoqParam context.Context
	Tx              types.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}
	mock.lockBroadcastTxAsync.RLock()
	calls = mock.calls.BroadcastTxAsync
	mock.lockBroadcastTxAsync.RUnlock()
	return calls
}

// BroadcastTxCommit calls BroadcastTxCommitFunc.
func (mock *ClientMock) BroadcastTxCommit(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
	if mock.BroadcastTxCommitFunc == nil {
		panic("ClientMock.BroadcastTxCommitFunc: method is nil but Client.BroadcastTxCommit was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxCommit.Lock()
	mock.calls.BroadcastTxCommit = append(mock.calls.BroadcastTxCommit, callInfo)
	mock.lockBroadcastTxCommit.Unlock()
	return mock.BroadcastTxCommitFunc(contextMoqParam, tx)
}

// BroadcastTxCommitCalls gets all the calls that were made to BroadcastTxCommit.
// Check the length with:
//
//	len(mockedClient.BroadcastTxCommitCalls())
func (mock *ClientMock) BroadcastTxCommitCalls() []struct {
	ContextMoqParam context.Context
	Tx              types.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}
	mock.lockBroadcastTxCommit.RLock()
	calls = mock.calls.BroadcastTxCommit
	mock.lockBroadcastTxCommit.RUnlock()
	return calls
}

// BroadcastTxSync calls BroadcastTxSyncFunc.
func (mock *ClientMock) BroadcastTxSync(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	if mock.BroadcastTxSyncFunc == nil {
		panic("ClientMock.BroadcastTxSyncFunc: method is nil but Client.BroadcastTxSync was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxSync.Lock()
	mock.calls.BroadcastTxSync = append(mock.calls.BroadcastTxSync, callInfo)
	mock.lockBroadcastTxSync.Unlock()
	return mock.BroadcastTxSyncFunc(contextMoqParam, tx)
}

// BroadcastTxSyncCalls gets all the calls that were made to BroadcastTxSync.
// Check the length with:
//
//	len(mockedClient.BroadcastTxSyncCalls())
func (mock *ClientMock) BroadcastTxSyncCalls() []struct {
	ContextMoqParam context.Context
	Tx              types.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}
	mock.lockBroadcastTxSync.RLock()
	calls = mock.calls.BroadcastTxSync
	mock.lockBroadcastTxSync.RUnlock()
	return calls
}

// CheckTx calls CheckTxFunc.
func (mock *ClientMock) CheckTx(contextMoqParam context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error) {
	if mock.CheckTxFunc == nil {
		panic("ClientMock.CheckTxFunc: method is nil but Client.CheckTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockCheckTx.Lock()
	mock.calls.CheckTx = append(mock.calls.CheckTx, callInfo)
	mock.lockCheckTx.Unlock()
	return mock.CheckTxFunc(contextMoqParam, tx)
}

// CheckTxCalls gets all the calls that were made to CheckTx.
// Check the length with:
//
//	len(mockedClient.CheckTxCalls())
func (mock *ClientMock) CheckTxCalls() []struct {
	ContextMoqParam context.Context
	Tx              types.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              types.Tx
	}
	mock.lockCheckTx.RLock()
	calls = mock.calls.CheckTx
	mock.lockCheckTx.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *ClientMock) Commit(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
	if mock.CommitFunc == nil {
		panic("ClientMock.CommitFunc: method is nil but Client.Commit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc(ctx, height)
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedClient.CommitCalls())
func (mock *ClientMock) CommitCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// ConsensusParams calls ConsensusParamsFunc.
func (mock *ClientMock) ConsensusParams(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
	if mock.ConsensusParamsFunc == nil {
		panic("ClientMock.ConsensusParamsFunc: method is nil but Client.ConsensusParams was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockConsensusParams.Lock()
	mock.calls.ConsensusParams = append(mock.calls.ConsensusParams, callInfo)
	mock.lockConsensusParams.Unlock()
	return mock.ConsensusParamsFunc(ctx, height)
}

// ConsensusParamsCalls gets all the calls that were made to ConsensusParams.
// Check the length with:
//
//	len(mockedClient.ConsensusParamsCalls())
func (mock *ClientMock) ConsensusParamsCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockConsensusParams.RLock()
	calls = mock.calls.ConsensusParams
	mock.lockConsensusParams.RUnlock()
	return calls
}

// ConsensusState calls ConsensusStateFunc.
func (mock *ClientMock) ConsensusState(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error) {
	if mock.ConsensusStateFunc == nil {
		panic("ClientMock.ConsensusStateFunc: method is nil but Client.ConsensusState was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockConsensusState.Lock()
	mock.calls.ConsensusState = append(mock.calls.ConsensusState, callInfo)
	mock.lockConsensusState.Unlock()
	return mock.ConsensusStateFunc(contextMoqParam)
}

// ConsensusStateCalls gets all the calls that were made to ConsensusState.
// Check the length with:
//
//	len(mockedClient.ConsensusStateCalls())
func (mock *ClientMock) ConsensusStateCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockConsensusState.RLock()
	calls = mock.calls.ConsensusState
	mock.lockConsensusState.RUnlock()
	return calls
}

// DumpConsensusState calls DumpConsensusStateFunc.
func (mock *ClientMock) DumpConsensusState(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error) {
	if mock.DumpConsensusStateFunc == nil {
		panic("ClientMock.DumpConsensusStateFunc: method is nil but Client.DumpConsensusState was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockDumpConsensusState.Lock()
	mock.calls.DumpConsensusState = append(mock.calls.DumpConsensusState, callInfo)
	mock.lockDumpConsensusState.Unlock()
	return mock.DumpConsensusStateFunc(contextMoqParam)
}

// DumpConsensusStateCalls gets all the calls that were made to DumpConsensusState.
// Check the length with:
//
//	len(mockedClient.DumpConsensusStateCalls())
func (mock *ClientMock) DumpConsensusStateCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockDumpConsensusState.RLock()
	calls = mock.calls.DumpConsensusState
	mock.lockDumpConsensusState.RUnlock()
	return calls
}

// Genesis calls GenesisFunc.
func (mock *ClientMock) Genesis(contextMoqParam context.Context) (*coretypes.ResultGenesis, error) {
	if mock.GenesisFunc == nil {
		panic("ClientMock.GenesisFunc: method is nil but Client.Genesis was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockGenesis.Lock()
	mock.calls.Genesis = append(mock.calls.Genesis, callInfo)
	mock.lockGenesis.Unlock()
	return mock.GenesisFunc(contextMoqParam)
}

// GenesisCalls gets all the calls that were made to Genesis.
// Check the length with:
//
//	len(mockedClient.GenesisCalls())
func (mock *ClientMock) GenesisCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockGenesis.RLock()
	calls = mock.calls.Genesis
	mock.lockGenesis.RUnlock()
	return calls
}

// GenesisChunked calls GenesisChunkedFunc.
func (mock *ClientMock) GenesisChunked(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
	if mock.GenesisChunkedFunc == nil {
		panic("ClientMock.GenesisChunkedFunc: method is nil but Client.GenesisChunked was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		V               uint
	}{
		ContextMoqParam: contextMoqParam,
		V:               v,
	}
	mock.lockGenesisChunked.Lock()
	mock.calls.GenesisChunked = append(mock.calls.GenesisChunked, callInfo)
	mock.lockGenesisChunked.Unlock()
	return mock.GenesisChunkedFunc(contextMoqParam, v)
}

// GenesisChunkedCalls gets all the calls that were made to GenesisChunked.
// Check the length with:
//
//	len(mockedClient.GenesisChunkedCalls())
func (mock *ClientMock) GenesisChunkedCalls() []struct {
	ContextMoqParam context.Context
	V               uint
} {
	var calls []struct {
		ContextMoqParam context.Context
		V               uint
	}
	mock.lockGenesisChunked.RLock()
	calls = mock.calls.GenesisChunked
	mock.lockGenesisChunked.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *ClientMock) Header(ctx context.Context, height *int64) (*coretypes.ResultHeader, error) {
	if mock.HeaderFunc == nil {
		panic("ClientMock.HeaderFunc: method is nil but Client.Header was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc(ctx, height)
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//
//	len(mockedClient.HeaderCalls())
func (mock *ClientMock) HeaderCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// HeaderByHash calls HeaderByHashFunc.
func (mock *ClientMock) HeaderByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error) {
	if mock.HeaderByHashFunc == nil {
		panic("ClientMock.HeaderByHashFunc: method is nil but Client.HeaderByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash bytes.HexBytes
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockHeaderByHash.Lock()
	mock.calls.HeaderByHash = append(mock.calls.HeaderByHash, callInfo)
	mock.lockHeaderByHash.Unlock()
	return mock.HeaderByHashFunc(ctx, hash)
}

// HeaderByHashCalls gets all the calls that were made to HeaderByHash.
// Check the length with:
//
//	len(mockedClient.HeaderByHashCalls())
func (mock *ClientMock) HeaderByHashCalls() []struct {
	Ctx  context.Context
	Hash bytes.HexBytes
} {
	var calls []struct {
		Ctx  context.Context
		Hash bytes.HexBytes
	}
	mock.lockHeaderByHash.RLock()
	calls = mock.calls.HeaderByHash
	mock.lockHeaderByHash.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *ClientMock) Health(contextMoqParam context.Context) (*coretypes.ResultHealth, error) {
	if mock.HealthFunc == nil {
		panic("ClientMock.HealthFunc: method is nil but Client.Health was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc(contextMoqParam)
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedClient.HealthCalls())
func (mock *ClientMock) HealthCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// IsRunning calls IsRunningFunc.
func (mock *ClientMock) IsRunning() bool {
	if mock.IsRunningFunc == nil {
		panic("ClientMock.IsRunningFunc: method is nil but Client.IsRunning was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsRunning.Lock()
	mock.calls.IsRunning = append(mock.calls.IsRunning, callInfo)
	mock.lockIsRunning.Unlock()
	return mock.IsRunningFunc()
}

// IsRunningCalls gets all the calls that were made to IsRunning.
// Check the length with:
//
//	len(mockedClient.IsRunningCalls())
func (mock *ClientMock) IsRunningCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsRunning.RLock()
	calls = mock.calls.IsRunning
	mock.lockIsRunning.RUnlock()
	return calls
}

// NetInfo calls NetInfoFunc.
func (mock *ClientMock) NetInfo(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error) {
	if mock.NetInfoFunc == nil {
		panic("ClientMock.NetInfoFunc: method is nil but Client.NetInfo was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNetInfo.Lock()
	mock.calls.NetInfo = append(mock.calls.NetInfo, callInfo)
	mock.lockNetInfo.Unlock()
	return mock.NetInfoFunc(contextMoqParam)
}

// NetInfoCalls gets all the calls that were made to NetInfo.
// Check the length with:
//
//	len(mockedClient.NetInfoCalls())
func (mock *ClientMock) NetInfoCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNetInfo.RLock()
	calls = mock.calls.NetInfo
	mock.lockNetInfo.RUnlock()
	return calls
}

// NumUnconfirmedTxs calls NumUnconfirmedTxsFunc.
func (mock *ClientMock) NumUnconfirmedTxs(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
	if mock.NumUnconfirmedTxsFunc == nil {
		panic("ClientMock.NumUnconfirmedTxsFunc: method is nil but Client.NumUnconfirmedTxs was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNumUnconfirmedTxs.Lock()
	mock.calls.NumUnconfirmedTxs = append(mock.calls.NumUnconfirmedTxs, callInfo)
	mock.lockNumUnconfirmedTxs.Unlock()
	return mock.NumUnconfirmedTxsFunc(contextMoqParam)
}

// NumUnconfirmedTxsCalls gets all the calls that were made to NumUnconfirmedTxs.
// Check the length with:
//
//	len(mockedClient.NumUnconfirmedTxsCalls())
func (mock *ClientMock) NumUnconfirmedTxsCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNumUnconfirmedTxs.RLock()
	calls = mock.calls.NumUnconfirmedTxs
	mock.lockNumUnconfirmedTxs.RUnlock()
	return calls
}

// OnReset calls OnResetFunc.
func (mock *ClientMock) OnReset() error {
	if mock.OnResetFunc == nil {
		panic("ClientMock.OnResetFunc: method is nil but Client.OnReset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnReset.Lock()
	mock.calls.OnReset = append(mock.calls.OnReset, callInfo)
	mock.lockOnReset.Unlock()
	return mock.OnResetFunc()
}

// OnResetCalls gets all the calls that were made to OnReset.
// Check the length with:
//
//	len(mockedClient.OnResetCalls())
func (mock *ClientMock) OnResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnReset.RLock()
	calls = mock.calls.OnReset
	mock.lockOnReset.RUnlock()
	return calls
}

// OnStart calls OnStartFunc.
func (mock *ClientMock) OnStart() error {
	if mock.OnStartFunc == nil {
		panic("ClientMock.OnStartFunc: method is nil but Client.OnStart was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnStart.Lock()
	mock.calls.OnStart = append(mock.calls.OnStart, callInfo)
	mock.lockOnStart.Unlock()
	return mock.OnStartFunc()
}

// OnStartCalls gets all the calls that were made to OnStart.
// Check the length with:
//
//	len(mockedClient.OnStartCalls())
func (mock *ClientMock) OnStartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnStart.RLock()
	calls = mock.calls.OnStart
	mock.lockOnStart.RUnlock()
	return calls
}

// OnStop calls OnStopFunc.
func (mock *ClientMock) OnStop() {
	if mock.OnStopFunc == nil {
		panic("ClientMock.OnStopFunc: method is nil but Client.OnStop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnStop.Lock()
	mock.calls.OnStop = append(mock.calls.OnStop, callInfo)
	mock.lockOnStop.Unlock()
	mock.OnStopFunc()
}

// OnStopCalls gets all the calls that were made to OnStop.
// Check the length with:
//
//	len(mockedClient.OnStopCalls())
func (mock *ClientMock) OnStopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnStop.RLock()
	calls = mock.calls.OnStop
	mock.lockOnStop.RUnlock()
	return calls
}

// Quit calls QuitFunc.
func (mock *ClientMock) Quit() <-chan struct{} {
	if mock.QuitFunc == nil {
		panic("ClientMock.QuitFunc: method is nil but Client.Quit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockQuit.Lock()
	mock.calls.Quit = append(mock.calls.Quit, callInfo)
	mock.lockQuit.Unlock()
	return mock.QuitFunc()
}

// QuitCalls gets all the calls that were made to Quit.
// Check the length with:
//
//	len(mockedClient.QuitCalls())
func (mock *ClientMock) QuitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockQuit.RLock()
	calls = mock.calls.Quit
	mock.lockQuit.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *ClientMock) Reset() error {
	if mock.ResetFunc == nil {
		panic("ClientMock.ResetFunc: method is nil but Client.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	return mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedClient.ResetCalls())
func (mock *ClientMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// SetLogger calls SetLoggerFunc.
func (mock *ClientMock) SetLogger(logger log.Logger) {
	if mock.SetLoggerFunc == nil {
		panic("ClientMock.SetLoggerFunc: method is nil but Client.SetLogger was just called")
	}
	callInfo := struct {
		Logger log.Logger
	}{
		Logger: logger,
	}
	mock.lockSetLogger.Lock()
	mock.calls.SetLogger = append(mock.calls.SetLogger, callInfo)
	mock.lockSetLogger.Unlock()
	mock.SetLoggerFunc(logger)
}

// SetLoggerCalls gets all the calls that were made to SetLogger.
// Check the length with:
//
//	len(mockedClient.SetLoggerCalls())
func (mock *ClientMock) SetLoggerCalls() []struct {
	Logger log.Logger
} {
	var calls []struct {
		Logger log.Logger
	}
	mock.lockSetLogger.RLock()
	calls = mock.calls.SetLogger
	mock.lockSetLogger.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ClientMock) Start() error {
	if mock.StartFunc == nil {
		panic("ClientMock.StartFunc: method is nil but Client.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedClient.StartCalls())
func (mock *ClientMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Status calls StatusFunc.
func (mock *ClientMock) Status(contextMoqParam context.Context) (*coretypes.ResultStatus, error) {
	if mock.StatusFunc == nil {
		panic("ClientMock.StatusFunc: method is nil but Client.Status was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockStatus.Lock()
	mock.calls.Status = append(mock.calls.Status, callInfo)
	mock.lockStatus.Unlock()
	return mock.StatusFunc(contextMoqParam)
}

// StatusCalls gets all the calls that were made to Status.
// Check the length with:
//
//	len(mockedClient.StatusCalls())
func (mock *ClientMock) StatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockStatus.RLock()
	calls = mock.calls.Status
	mock.lockStatus.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *ClientMock) Stop() error {
	if mock.StopFunc == nil {
		panic("ClientMock.StopFunc: method is nil but Client.Stop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	return mock.StopFunc()
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//
//	len(mockedClient.StopCalls())
func (mock *ClientMock) StopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *ClientMock) String() string {
	if mock.StringFunc == nil {
		panic("ClientMock.StringFunc: method is nil but Client.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedClient.StringCalls())
func (mock *ClientMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *ClientMock) Subscribe(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
	if mock.SubscribeFunc == nil {
		panic("ClientMock.SubscribeFunc: method is nil but Client.Subscribe was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Subscriber  string
		Query       string
		OutCapacity []int
	}{
		Ctx:         ctx,
		Subscriber:  subscriber,
		Query:       query,
		OutCapacity: outCapacity,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, subscriber, query, outCapacity...)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedClient.SubscribeCalls())
func (mock *ClientMock) SubscribeCalls() []struct {
	Ctx         context.Context
	Subscriber  string
	Query       string
	OutCapacity []int
} {
	var calls []struct {
		Ctx         context.Context
		Subscriber  string
		Query       string
		OutCapacity []int
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}

// Tx calls TxFunc.
func (mock *ClientMock) Tx(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error) {
	if mock.TxFunc == nil {
		panic("ClientMock.TxFunc: method is nil but Client.Tx was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Hash  []byte
		Prove bool
	}{
		Ctx:   ctx,
		Hash:  hash,
		Prove: prove,
	}
	mock.lockTx.Lock()
	mock.calls.Tx = append(mock.calls.Tx, callInfo)
	mock.lockTx.Unlock()
	return mock.TxFunc(ctx, hash, prove)
}

// TxCalls gets all the calls that were made to Tx.
// Check the length with:
//
//	len(mockedClient.TxCalls())
func (mock *ClientMock) TxCalls() []struct {
	Ctx   context.Context
	Hash  []byte
	Prove bool
} {
	var calls []struct {
		Ctx   context.Context
		Hash  []byte
		Prove bool
	}
	mock.lockTx.RLock()
	calls = mock.calls.Tx
	mock.lockTx.RUnlock()
	return calls
}

// TxSearch calls TxSearchFunc.
func (mock *ClientMock) TxSearch(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
	if mock.TxSearchFunc == nil {
		panic("ClientMock.TxSearchFunc: method is nil but Client.TxSearch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Prove   bool
		Page    *int
		PerPage *int
		OrderBy string
	}{
		Ctx:     ctx,
		Query:   query,
		Prove:   prove,
		Page:    page,
		PerPage: perPage,
		OrderBy: orderBy,
	}
	mock.lockTxSearch.Lock()
	mock.calls.TxSearch = append(mock.calls.TxSearch, callInfo)
	mock.lockTxSearch.Unlock()
	return mock.TxSearchFunc(ctx, query, prove, page, perPage, orderBy)
}

// TxSearchCalls gets all the calls that were made to TxSearch.
// Check the length with:
//
//	len(mockedClient.TxSearchCalls())
func (mock *ClientMock) TxSearchCalls() []struct {
	Ctx     context.Context
	Query   string
	Prove   bool
	Page    *int
	PerPage *int
	OrderBy string
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Prove   bool
		Page    *int
		PerPage *int
		OrderBy string
	}
	mock.lockTxSearch.RLock()
	calls = mock.calls.TxSearch
	mock.lockTxSearch.RUnlock()
	return calls
}

// UnconfirmedTxs calls UnconfirmedTxsFunc.
func (mock *ClientMock) UnconfirmedTxs(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error) {
	if mock.UnconfirmedTxsFunc == nil {
		panic("ClientMock.UnconfirmedTxsFunc: method is nil but Client.UnconfirmedTxs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit *int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockUnconfirmedTxs.Lock()
	mock.calls.UnconfirmedTxs = append(mock.calls.UnconfirmedTxs, callInfo)
	mock.lockUnconfirmedTxs.Unlock()
	return mock.UnconfirmedTxsFunc(ctx, limit)
}

// UnconfirmedTxsCalls gets all the calls that were made to UnconfirmedTxs.
// Check the length with:
//
//	len(mockedClient.UnconfirmedTxsCalls())
func (mock *ClientMock) UnconfirmedTxsCalls() []struct {
	Ctx   context.Context
	Limit *int
} {
	var calls []struct {
		Ctx   context.Context
		Limit *int
	}
	mock.lockUnconfirmedTxs.RLock()
	calls = mock.calls.UnconfirmedTxs
	mock.lockUnconfirmedTxs.RUnlock()
	return calls
}

// Unsubscribe calls UnsubscribeFunc.
func (mock *ClientMock) Unsubscribe(ctx context.Context, subscriber string, query string) error {
	if mock.UnsubscribeFunc == nil {
		panic("ClientMock.UnsubscribeFunc: method is nil but Client.Unsubscribe was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Subscriber string
		Query      string
	}{
		Ctx:        ctx,
		Subscriber: subscriber,
		Query:      query,
	}
	mock.lockUnsubscribe.Lock()
	mock.calls.Unsubscribe = append(mock.calls.Unsubscribe, callInfo)
	mock.lockUnsubscribe.Unlock()
	return mock.UnsubscribeFunc(ctx, subscriber, query)
}

// UnsubscribeCalls gets all the calls that were made to Unsubscribe.
// Check the length with:
//
//	len(mockedClient.UnsubscribeCalls())
func (mock *ClientMock) UnsubscribeCalls() []struct {
	Ctx        context.Context
	Subscriber string
	Query      string
} {
	var calls []struct {
		Ctx        context.Context
		Subscriber string
		Query      string
	}
	mock.lockUnsubscribe.RLock()
	calls = mock.calls.Unsubscribe
	mock.lockUnsubscribe.RUnlock()
	return calls
}

// UnsubscribeAll calls UnsubscribeAllFunc.
func (mock *ClientMock) UnsubscribeAll(ctx context.Context, subscriber string) error {
	if mock.UnsubscribeAllFunc == nil {
		panic("ClientMock.UnsubscribeAllFunc: method is nil but Client.UnsubscribeAll was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Subscriber string
	}{
		Ctx:        ctx,
		Subscriber: subscriber,
	}
	mock.lockUnsubscribeAll.Lock()
	mock.calls.UnsubscribeAll = append(mock.calls.UnsubscribeAll, callInfo)
	mock.lockUnsubscribeAll.Unlock()
	return mock.UnsubscribeAllFunc(ctx, subscriber)
}

// UnsubscribeAllCalls gets all the calls that were made to UnsubscribeAll.
// Check the length with:
//
//	len(mockedClient.UnsubscribeAllCalls())
func (mock *ClientMock) UnsubscribeAllCalls() []struct {
	Ctx        context.Context
	Subscriber string
} {
	var calls []struct {
		Ctx        context.Context
		Subscriber string
	}
	mock.lockUnsubscribeAll.RLock()
	calls = mock.calls.UnsubscribeAll
	mock.lockUnsubscribeAll.RUnlock()
	return calls
}

// Validators calls ValidatorsFunc.
func (mock *ClientMock) Validators(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error) {
	if mock.ValidatorsFunc == nil {
		panic("ClientMock.ValidatorsFunc: method is nil but Client.Validators was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Height  *int64
		Page    *int
		PerPage *int
	}{
		Ctx:     ctx,
		Height:  height,
		Page:    page,
		PerPage: perPage,
	}
	mock.lockValidators.Lock()
	mock.calls.Validators = append(mock.calls.Validators, callInfo)
	mock.lockValidators.Unlock()
	return mock.ValidatorsFunc(ctx, height, page, perPage)
}

// ValidatorsCalls gets all the calls that were made to Validators.
// Check the length with:
//
//	len(mockedClient.ValidatorsCalls())
func (mock *ClientMock) ValidatorsCalls() []struct {
	Ctx     context.Context
	Height  *int64
	Page    *int
	PerPage *int
} {
	var calls []struct {
		Ctx     context.Context
		Height  *int64
		Page    *int
		PerPage *int
	}
	mock.lockValidators.RLock()
	calls = mock.calls.Validators
	mock.lockValidators.RUnlock()
	return calls
}
